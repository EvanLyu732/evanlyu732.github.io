<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>


    
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://evanlyu732.github.io/atom.xml">
    
    
    
        
    
    
    
    
    
    
        
    
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>五分钟读论文: Scaling and evaluating sparse autoencoders - evan lyu</title>
    <meta charset="utf-8">
    <meta name="title" content="五分钟读论文: Scaling and evaluating sparse autoencoders - evan lyu">
    <meta name="description" content="">
    <meta property="og:image:width" content="200" />
    <meta property="og:image:height" content="200" />
    <link rel="stylesheet" href="https:&#x2F;&#x2F;evanlyu732.github.io/style.css">
    
    
    <style>
    @media screen and (min-width: 320px) {
        body {
            font-size: calc(16px + 2 * ((100vw - 320px) / 960));
        }
    }
    </style>
    
    <link rel="stylesheet" href="https://fonts.loli.net/css2?family=Source+Serif+Pro:wght@400;700&display=swap">
    <link rel="stylesheet" href="https://fonts.loli.net/css2?family=Noto+Serif+SC:wght@400;700&display=swap">
    <style>body { font-family: 'Source Serif Pro', 'Source Han Serif SC', 'Noto Serif CJK SC', 'Noto Serif SC', serif }</style>
    
</head>
<body>
    
    <header class="header">
        <div class="blog-title"><a href="https:&#x2F;&#x2F;evanlyu732.github.io" class="logo">evan lyu</a></div>
        <nav class="navbar">
    <ul class="menu">
        
        
        <li class="menu-item">
            
            
            
            
            <a href="https:&#x2F;&#x2F;evanlyu732.github.io&#x2F;" class="menu-item-link">主页</a>
            
        </li>
        
        <li class="menu-item">
            
            
            
            
            <a href="https:&#x2F;&#x2F;evanlyu732.github.io&#x2F;archives" class="menu-item-link">归档</a>
            
        </li>
        
        <li class="menu-item">
            
            
            
            
            <a href="https:&#x2F;&#x2F;evanlyu732.github.io&#x2F;about" class="menu-item-link">关于</a>
            
        </li>
        
        <li class="menu-item">
            
            
            
            
            <a href="https:&#x2F;&#x2F;evanlyu732.github.io&#x2F;note" class="menu-item-link">书架</a>
            
        </li>
        
        <li class="menu-item">
            
            
            
            
            <a href="https:&#x2F;&#x2F;evanlyu732.github.io&#x2F;atom.xml" class="menu-item-link">订阅</a>
            
        </li>
        
    </ul>
</nav>

    </header>
    
    <main class="main">
        
<article class="post">
    <div class="post-title">
        <h1 class="title">五分钟读论文: Scaling and evaluating sparse autoencoders</h1>
    </div>
    <div class="post-content">
        <p>这几天OpenAI新发了一篇<a href="https://openai.com/index/extracting-concepts-from-gpt-4/">博客</a>关于使用sparse-autoencoders去解释GPT4的内部机制. 本文是对论文的解读方便读者快速获取关键信息, 如果好求甚解, 请点击传送门:</p>
<ul>
<li>blog: <a href="https://openai.com/index/extracting-concepts-from-gpt-4/">Extracting Concepts from GPT-4</a></li>
<li>paper: <a href="https://cdn.openai.com/papers/sparse-autoencoders.pdf">Scaling and evaluating sparse autoencoders</a></li>
<li>code: <a href="https://github.com/openai/sparse_autoencoder">openai/sparse_autoencoder</a></li>
</ul>
<p><a id="目录"></a></p>
<h1 id="mu-lu">目录</h1>
<ul>
<li><a href="https://evanlyu732.github.io/blog10/#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="https://evanlyu732.github.io/blog10/#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86">背景知识</a>
<ul>
<li><a href="https://evanlyu732.github.io/blog10/#autoencoder">Autoencoder</a></li>
<li><a href="https://evanlyu732.github.io/blog10/#sparse-autoencoder">Sparse Autoencoder</a></li>
<li><a href="https://evanlyu732.github.io/blog10/#sparse-autoencoder%E7%9A%84%E7%89%B9%E5%BE%81%E5%8F%AF%E8%A7%A3%E9%87%8A%E6%80%A7">Sparse Autoencoder的特征可解释性</a></li>
<li><a href="https://evanlyu732.github.io/blog10/#bottleneck-layer">Bottleneck Layer</a></li>
<li><a href="https://evanlyu732.github.io/blog10/#topk%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0">TopK激活函数</a></li>
</ul>
</li>
<li><a href="https://evanlyu732.github.io/blog10/#%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB">论文解读</a></li>
<li><a href="https://evanlyu732.github.io/blog10/#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<p>如果对背景知识不太了解的话, 推荐顺序阅读. 如果已经有足够的背景知识, 请点击<a href="https://evanlyu732.github.io/blog10/#%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB">这里</a>开始正文阅读. 下面是对论文的解读. </p>
<p><a id="背景知识"></a></p>
<h1 id="bei-jing-zhi-shi">背景知识</h1>
<p><a id="Autoencoder"></a></p>
<h2 id="autoencoder">Autoencoder</h2>
<p>根据吴恩达在CS294A的<a href="http://stanford.edu/class/cs294a/sparseAutoencoder.pdf">讲义</a>, Autoencoder是一种无监督学习, 在没有给定标签的数据{x(1), x(2), x(3)....}, 通过隐藏层(hidden layer)学习输入中隐含的特征, 从而让输出{x^(1), x^(2), x^(3)...}尽可能的逼近输入. 下图为autoencoder的结构(引用自<a href="http://stanford.edu/class/cs294a/sparseAutoencoder.pdf">这里</a>):</p>
<img src="https://raw.githubusercontent.com/EvanLyu732/evanlyu732.github.io/main/static/images/autoencoder.png" height="100" width="100"/>
<!-- ![autoencoder](https://raw.githubusercontent.com/EvanLyu732/evanlyu732.github.io/main/static/images/autoencoder.png) -->
<p><a id="Sparse Autoencoder"></a></p>
<h2 id="sparse-autoencoder">Sparse Autoencoder</h2>
<p>Sparse Autoencoder是Autoencoder的一种变种, 在Autoencoder的基础上通过增加稀疏惩罚项(sparse penalty)使得前向传播时只有一部分神经元激活, 而不是所有神经元都激活. 由于相比与未做稀疏化处理的autoencoder结构, 激活的隐藏层神经元(hidden neruon)变少了, 因此每一个隐藏层神经元都包含了更丰富的隐藏特征(latent feature). 是不是和现在流行的<a href="https://huggingface.co/blog/moe">Mixture of Experts</a>很像? 
下图为sparse autoencoder的结构(引用自<a href="https://medium.com/@syoya/what-happens-in-sparse-autencoder-b9a5a69da5c6">这里</a>):</p>
<p><img src="https://raw.githubusercontent.com/EvanLyu732/evanlyu732.github.io/main/static/images/sparse-autoencoder2.png" alt="sparse-autoencoder" /></p>
<p><a id="sparse-autoencoder的特征可解释性"></a></p>
<h2 id="sparse-autoencoderde-te-zheng-ke-jie-shi-xing">Sparse Autoencoder的特征可解释性</h2>
<p>MIT6.S898 Deep Learning在2023年发表的一篇<a href="https://deep-learning-mit.github.io/staging/blog/2023/learning-interpretable-features-with-sparse-autoencoders/">blog</a>在这里提到了</p>
<blockquote>
<p>A sparse autoencoder lets us learn a sparse representation for a vector, but in a higher dimensional space.</p>
</blockquote>
<p>相比与未稀疏化的Autoencoder, 稀疏化的Autoencoder可以学习到更高维度的隐含特征. 换个角度说, 未经稀疏化的隐藏层神经往往是表示多维特征(polysemantic). 而经过稀疏化的隐藏层神经元所表示的特征维度更少, 从而使得隐含特征更加容易理解. 更详细的关于sparse autoencoder的可解释性, 可以点击Anthropic发的<a href="https://transformer-circuits.pub/2023/monosemantic-features">&quot;Towards Monosemanticity: Decomposing Language Models With Dictionary Learning&quot;</a>查看.</p>
<p><a id="Bottleneck Layer"></a></p>
<h2 id="bottleneck-layer">Bottleneck Layer</h2>
<p>bottlenect layer指的是含有比前一层更少的神经元的网络层, 使得输入特征维度减少. 这里引用英文原文更方便理解:</p>
<blockquote>
<p>A bottleneck layer is a layer that contains few nodes compared to the previous layers. It can be used to obtain a representation of the input with reduced dimensionality.</p>
</blockquote>
<p><a id="TopK激活函数"></a></p>
<h2 id="topkji-huo-han-shu">TopK激活函数</h2>
<p>TopK是一种激活函数. 仅保留输入向量中最大的k的值，其余值设置为0.</p>
<p><a id="论文解读"></a></p>
<h1 id="lun-wen-jie-du">论文解读</h1>
<p>ok, 我们已经了解了所有的前置知识, 接下来我们开始看这篇文章. 首先是作者部分还有Ilya Sutskever与Jan Leike, 说明是OpenAI之前研究的存货. 再来看摘要部分:</p>
<p><img src="https://raw.githubusercontent.com/EvanLyu732/evanlyu732.github.io/main/static/images/openai-papers.png" alt="paper-abstract" /></p>
<p>黄色部分的文字是这篇文章所解决的问题, 绿色部分是作者提出的解决方案. </p>
<ul>
<li><strong>问题</strong> : 随着输入特征的增加, 训练sparse autoencoder会难以平衡稀疏性与准确性. 稀疏性指的是如何确定哪些神经元需要激活, 哪些神经元不需要激活. 准确性是指经过稀疏化处理后的隐藏层神经元所表示的隐含特征是否与原始输入特征相似(见背景知识Autoencoder). </li>
<li><strong>解决方案</strong> : 作者使用k-sparse autoencoder去控制稀疏性从而实现平衡. </li>
</ul>
<p>到了正文部分, 作者一开始比较了不同的激活函数对autoencoder的影响. 发现TopK的获得最小的正规化均方根误差(Normalized root mean square error). 如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/EvanLyu732/evanlyu732.github.io/main/static/images/openai-topk.png" alt="topk" /></p>
<p>接下来作者在不同指标上又进行了测试, 如果有兴趣建议阅读原文. 为了抓住重点, 我们先跳过这一部分. 作者使用<a href="https://arxiv.org/pdf/2305.19911">Neuron to Graph(N2G)</a>去做特征的解释.</p>
<p><img src="https://raw.githubusercontent.com/EvanLyu732/evanlyu732.github.io/main/static/images/n2g.png" alt="n2g" /></p>
<p>上图的N2G论文原文的描述, 可以看到N2G是将语言模型输出的回答进行关联生成一张有向图. </p>
<p>之后作者对比了ReLU与TopK在N2G中的表现. 发现TopK的召回率以及精度都更高. 如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/EvanLyu732/evanlyu732.github.io/main/static/images/openai-result.png" alt="result" /></p>
<p>最后作者给出了结论以及未来工作的方向:</p>
<p><img src="https://raw.githubusercontent.com/EvanLyu732/evanlyu732.github.io/main/static/images/paper-result.png" alt="paper-result" /></p>
<p><a id="参考资料"></a></p>
<h1 id="can-kao-zi-liao">参考资料</h1>
<ul>
<li><a href="http://stanford.edu/class/cs294a/sparseAutoencoder.pdf">Sparse autoencoder, CS294A Lecture notes - Andrew Ng</a></li>
<li><a href="https://stats.stackexchange.com/questions/262044/what-does-a-bottleneck-layer-mean-in-neural-networks">What does a bottleneck layer mean in neural networks?</a></li>
</ul>
<hr />
<br>
<br>
<p>(第一次写这种论文解读类文章, 发现还是不好写. 因为有条件的话应该直接读原文, 不加如一些原文的图的话会表达不到意思, 加了太多又和读原文没什么区别.)</p>

    </div>
    <div class="post-meta">
        <span class="post-time">
        
            


二〇二四年六月七日

        
        </span>
    </div>
</article>

<div class="prev_next">
<nav id="prev_next">
    <div class="prev">
        
    </div>
    <div class="next">
        
    </div>
</nav>
</div>

<div class="post-comment">




</div>

    </main>
    
    <p class="license"></p>
    
</body>
</html>
